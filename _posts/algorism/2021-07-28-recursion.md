---
title: '재귀란?'
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true
categories:
- Algorism

# table of contents
toc: true # 오른쪽 부분에 목차를 자동 생성해준다.
toc_label: "table of content" # toc 이름 설정
toc_icon: "bars" # 아이콘 설정
toc_sticky: true # 마우스 스크롤과 함께 내려갈 것인지 설정
---

## 재귀함수란
⇒자신이 수행할 작업을 **유사한 형태의 여러 조각으로 쪼갠 뒤** 그 중 한 조각을 수행하고 나머지는 자기 자신을 호출해 실행하는 함수

### 유사한 형태의 여러 조각?
1)재귀의 깊이<br/>
2)재귀 호출 시 반복되는 부분<br/>

```java
//ex)0부터 n개의 원소 중 네 개를 고르는 모든 경우
for(int i = 0; i < n; i++){
    for(int j = i + 1; j < n; j++){
        for(int k = j + 1; k < n; k++){
            for(int l = k + 1; l < n; l++){
                System.out.println(i+" "+j+" "+k+" "+l);
            }
        }
    }
}

//여기서 각 for문이 유사한 형태의 조각으로 쪼갠다고 볼 수 있음.
```

**⭐유사한 형태의 조각으로 나누고 자기 자신을 호출할 때 변경되어야 하는 값이 무엇인지 찾는 것이 포인트**

## 기저 사례란
⇒ 더이상 쪼개지지 않는 최소한의 작업에 도달했을 때 답을 곧장 반환하는 조건문

⭐기저 사례를 선택할 때는 **존재하는 모든 입력이 항상 기저 사례의 답을 이용해 계산될 수 있도록** 신경써야 한다.
```java
//ex)1부터 n까지의 답을 구하는 재귀 함수
public int recursiveSum(int n){
    if(n == 2) return 3;
    return n + recursiveSum(n-1);
}

//2 이상의 값을 입력할 경우 2+1의 값인 3을 리턴하기 때문에 문제가
//없지만 1이 입력되는 경우 기저사례가 작동되지 않기 때문에 잘못된 
//기저사례라 할 수 있다.
```

## 재귀함수 작성 시 고려해야 할 사항
1)어떻게 쪼갤 것 인가?  유사한 형태의 조각

2)수행 뒤 나머지 연산을 넘길 때 변경되어야 하는 값이 무엇인가?

3)기저 사례 즉 더이상 쪼개지지 않는 최소한의 작업이 어떤 것인가?

4)자신이 해결할 문제와 넘겨야 할 문제가 무엇인가?

## 시간 복잡도 분석
완전 탐색은 가능한 답 후보들을 모두 만들어 보기 때문에, 시간 복잡도를 계산하기 위해서는
가능한 후보의 수를 전부 세어보기만 하면 된다.

시간 안에 동작함을 확인하기 위해서는 답 후보의 최대 갯수를 계산하면 된다.

## 완전 탐색 레시피
1)시간 안의 완전 탐색이 가능한지 최대 크기의 후보 갯수를 계산한다.

2)답 후보를 만드는 과정을 여러 개의 조각으로 나눈다.<br>
각 조각은 답의 후보를 만드는 과정의 하나가 된다.

3)그 중 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성한다.

4)조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우에는 답을 생성했으므로, 이것을 기저 사례로 처리한다.